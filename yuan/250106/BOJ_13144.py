"""
연속한 수 뽑을때 같은 수가 등장하지 않는 경우의 수 
[1,2,3,1,2] 에서 
index[0] 을 뽑은 경우랑 index[4] 뽑는 건 다른 경우
**중복 이랑 관련 없는 문제임** 

따라서 각 index를 뽑았을 떄의 가능한 경우 수를 체크해줘야함
index[0] 을 뽑았을때 가능한 수는 1 12 123 
[1]: 2 23 231

res+=(r-l+1) 이 식은 
새로운 요소가 집합에 추가되었을때 
해당 요소로 끝나는 수열들의 개수만 세는 식 
[1,2] -> [1,2,3] 이 되었을떄
3 / 23 의 개수를 세서 더하게 됨 

[1] -> [1]
[1,2] -> [2], [1,2] 
[1,2,3] -> [3], [2,3] , [1,2,3]
... 


"""

n = int(input())
arr = list(map(int,input().split()))

res = 0
l=0
check = [0] *100001

for r in range(n):
    while check[arr[r]] > 0:
        check[arr[l]] -=1
        l+=1
    # 현재 중복이 없는 집합상태
    check[arr[r]] =1
    # 부분집합 개수 구하는 식
    res+=(r-l+1)

print(res)
